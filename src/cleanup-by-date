#!/usr/bin/env bash
set -euo pipefail

show_help() {
  cat <<EOF
Usage: cleanup-by-date <path> <period> [--regex <regex>] [--log <file>] [--dry-run] [--now <date>]

Arguments:
  <path>        Directory to scan
  <period>      Time threshold (e.g. 7d, 1w, 24h, 1y)

Options:
  --regex <regex> Regex with optional capturing group for date (default: ([0-9]{4}-[0-9]{2}-[0-9]{2}(_[0-9]{4})?))
  --log <file>    Write actions to specified log file
  --dry-run       Simulate deletions
  --now <date>    Override current date (format: 'YYYY-MM-DD HH:MM:SS')

Date format:
  Expected: 2024-12-01 or 2024-12-01_1200
  If regex has a group, it must capture this part.
EOF
}

if [[ $# -lt 2 ]] || [[ $1 == "--help" ]]; then
  show_help
  exit 0
fi

DIR=$1
PERIOD=$2
shift 2

REGEX='([0-9]{4}-[0-9]{2}-[0-9]{2}(_[0-9]{4})?)'
DRY_RUN=false
LOG_FILE=""
NOW_OVERRIDE=""

while (($#)); do
  case $1 in
    --regex) [[ $# -ge 2 ]] && REGEX=$2 && shift || { echo "Missing value for --regex"; exit 1; } ;;
    --log) [[ $# -ge 2 ]] && LOG_FILE=$2 && shift || { echo "Missing value for --log"; exit 1; } ;;
    --dry-run) DRY_RUN=true ;;
    --now) [[ $# -ge 2 ]] && NOW_OVERRIDE=$2 && shift || { echo "Missing value for --now"; exit 1; } ;;
    *) echo "Unknown option: $1" >&2; show_help; exit 1 ;;
  esac
  shift
done

if [[ ! -d "$DIR" ]]; then
  echo "[ERROR] Directory does not exist: $DIR" >&2
  exit 2
fi

DATE_BIN=$(command -v gdate || echo date)

if [[ -n "$NOW_OVERRIDE" ]]; then
  now_local=$($DATE_BIN -u -d "$NOW_OVERRIDE" "+%Y-%m-%d %H:%M:%S") || {
    echo "[ERROR] Invalid date for --now: $NOW_OVERRIDE" >&2
    exit 3
  }
else
  now_local=$($DATE_BIN -u "+%Y-%m-%d %H:%M:%S")
fi

case $PERIOD in
  *y) unit=year; val="${PERIOD%y}" ;;
  *w) unit=week; val="${PERIOD%w}" ;;
  *m) unit=month; val="${PERIOD%m}" ;;
  *d) unit=day;  val="${PERIOD%d}" ;;
  *h) unit=hour; val="${PERIOD%h}" ;;
  *) echo "[ERROR] Invalid period format: $PERIOD" >&2; exit 3 ;;
esac

if [[ "$val" == "0" ]]; then
  cutoff="$now_local"
else
  cutoff=$($DATE_BIN -u -d "$now_local UTC -${val} ${unit}" "+%Y-%m-%d %H:%M:%S")
fi

log() {
  local msg="[INFO] $1"
  [[ -n $LOG_FILE ]] && echo "$msg" >>"$LOG_FILE" || echo "$msg"
}

extract_datetime() {
  local input="$1"
  if [[ $input =~ ([0-9]{4}-[0-9]{2}-[0-9]{2})_([0-9]{4}) ]]; then
    echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]:0:2}:${BASH_REMATCH[2]:2:2}"
  elif [[ $input =~ ([0-9]{4}-[0-9]{2}-[0-9]{2}) ]]; then
    echo "${BASH_REMATCH[1]} 00:00"
  else
    return 1
  fi
}

validate_regex() {
  local regex="$1"
  local dir="$2"
  local found=""
  local f fname full

  for f in "$dir"/*; do
    [[ -f "$f" ]] || continue
    fname=$(basename "$f")
    if [[ "$fname" =~ $regex ]]; then
      if [[ ${#BASH_REMATCH[@]} -gt 1 ]]; then
        found="${BASH_REMATCH[1]}"
      else
        found="${BASH_REMATCH[0]}"
      fi
      break
    fi
  done

  if [[ -z $found ]]; then
    echo "[ERROR] Regex does not match any filenames in $dir" >&2
    exit 4
  fi

  full=$(extract_datetime "$found") || {
    echo "[ERROR] Extracted date '$found' is not parseable" >&2
    exit 4
  }

  if ! $DATE_BIN -u -d "$full" "+%Y-%m-%d %H:%M:%S" >/dev/null 2>&1; then
      echo "[WARN] Skipping unparseable datetime: $full"
      return
  fi
}

validate_regex "$REGEX" "$DIR"

log "NOW=$now_local, PERIOD=$PERIOD, CUTOFF=$cutoff"
log "Using regex: $REGEX"

deleted=0
for file in "$DIR"/*; do
  [[ -f "$file" ]] || continue
  if [[ $(basename "$file") =~ $REGEX ]]; then
    if [[ ${#BASH_REMATCH[@]} -gt 1 ]]; then
      match="${BASH_REMATCH[1]}"
    else
      match="${BASH_REMATCH[0]}"
    fi
    parsed_date=$(extract_datetime "$match")
    if [[ -n $parsed_date ]]; then
      file_ts=$($DATE_BIN -u -d "$parsed_date" +%s 2>/dev/null || echo "")
      cutoff_ts=$($DATE_BIN -u -d "$cutoff" +%s 2>/dev/null || echo "")
      if [[ -z "$cutoff_ts" ]]; then
        echo "[ERROR] Failed to parse cutoff: '$cutoff'" >&2
        exit 5
      fi

      if [[ -n "$file_ts" && -n "$cutoff_ts" ]]; then
        if (( file_ts <= cutoff_ts )); then
          if $DRY_RUN; then
            log "Would delete: $file (file date: $parsed_date)"
          else
            rm -f "$file"
            log "Deleted: $file (file date: $parsed_date)"
          fi
          ((deleted++))
        fi
      fi
    fi
  fi
done

log "Done. Files deleted: $deleted"
exit 0
